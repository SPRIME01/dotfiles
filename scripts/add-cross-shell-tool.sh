#!/usr/bin/env bash
set -euo pipefail

usage() {
	cat <<'USAGE'
Usage: add-cross-shell-tool.sh [--name NAME] [--posix-path PATH] [--ps-segments SEG,MENT]

Environment variables:
  TOOL_NAME     Override the tool name (kebab-case recommended)
  POSIX_PATH    Override the POSIX installation directory (e.g. $HOME/.local/bin)
  PS_SEGMENTS   Optional comma-separated segments relative to %USERPROFILE%

When arguments are omitted the script prompts interactively.
USAGE
}

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
POSIX_TOOLS_DIR="$REPO_ROOT/shell/common/tools.d/sh"
PS_TOOLS_DIR="$REPO_ROOT/shell/common/tools.d/ps1"

tool_name="${TOOL_NAME:-}"
posix_path="${POSIX_PATH:-}"
ps_segments_raw="${PS_SEGMENTS:-}"

while [[ $# -gt 0 ]]; do
	case "$1" in
		--name)
			[[ $# -ge 2 ]] || { echo "--name requires a value" >&2; exit 1; }
			tool_name="$2"
			shift 2
			;;
		--posix-path)
			[[ $# -ge 2 ]] || { echo "--posix-path requires a value" >&2; exit 1; }
			posix_path="$2"
			shift 2
			;;
		--ps-segments)
			[[ $# -ge 2 ]] || { echo "--ps-segments requires a value" >&2; exit 1; }
			ps_segments_raw="$2"
			shift 2
			;;
		-h|--help)
			usage
			exit 0
			;;
		*)
			echo "Unknown argument: $1" >&2
			usage
			exit 1
			;;
	esac
done

read_input() {
	local prompt="$1"
	local default_value="${2-}"
	local response
	if [[ -n "$default_value" ]]; then
		read -r -p "$prompt [$default_value]: " response
		if [[ -z "$response" ]]; then
			response="$default_value"
		fi
	else
		read -r -p "$prompt: " response
	fi
	echo "$response"
}

if [[ -z "$tool_name" ]]; then
	tool_name=$(read_input "Tool name (kebab-case)")
fi

tool_name="${tool_name,,}"
if [[ ! "$tool_name" =~ ^[a-z0-9][a-z0-9_-]*$ ]]; then
	echo "Invalid tool name: $tool_name" >&2
	exit 1
fi

if [[ -z "$posix_path" ]]; then
	posix_path=$(read_input "POSIX install directory" "\$HOME/.local/bin")
fi

if [[ -z "$posix_path" ]]; then
	echo "POSIX path is required" >&2
	exit 1
fi

suffix=""
case "$posix_path" in
	\$HOME/*)
		suffix="${posix_path#\$HOME/}"
		;;
	~/*)
		suffix="${posix_path#~/}"
		;;
	*)
		echo "Only paths under \$HOME are supported to avoid hardcoding absolute Windows locations." >&2
		echo "Received: $posix_path" >&2
		exit 1
		;;
esac

IFS='/' read -r -a derived_segments <<<"$suffix"

if [[ -z "$ps_segments_raw" ]]; then
	ps_segments_raw=$(printf '%s,' "${derived_segments[@]}")
	ps_segments_raw="${ps_segments_raw%,}"
fi

if [[ -z "$ps_segments_raw" ]]; then
	echo "Unable to determine PowerShell path segments" >&2
	exit 1
fi

IFS=',' read -r -a ps_segments <<<"$ps_segments_raw"
ps_segment_literals=()
for segment in "${ps_segments[@]}"; do
	segment="$(printf '%s' "$segment" | xargs)"
	if [[ -z "$segment" ]]; then
		continue
	fi
	escaped_segment=${segment//\'/\'\'}
	ps_segment_literals+=("'$escaped_segment'")
done

if [[ "${#ps_segment_literals[@]}" -eq 0 ]]; then
	echo "PowerShell segment list is empty" >&2
	exit 1
fi

joined_segments=""
for lit in "${ps_segment_literals[@]}"; do
	joined_segments+="$lit,"
done
joined_segments="${joined_segments%,}"
ps_segment_array="@(${joined_segments})"

mkdir -p "$POSIX_TOOLS_DIR" "$PS_TOOLS_DIR"

posix_file="$POSIX_TOOLS_DIR/$tool_name.sh"
ps_file="$PS_TOOLS_DIR/$tool_name.ps1"

if [[ -e "$posix_file" || -e "$ps_file" ]]; then
	echo "Refusing to overwrite existing tool definitions for $tool_name" >&2
	exit 1
fi

posix_path_escaped=${posix_path//\"/\\\"}

cat <<POSIX_SNIPPET >"$posix_file"
# shellcheck shell=bash
# Auto-generated by scripts/add-cross-shell-tool.sh
# Adds $tool_name to PATH when available.

tool_dir="$posix_path_escaped"
if [[ -d "\$tool_dir" ]]; then
	add_path_once "\$tool_dir"
fi
POSIX_SNIPPET

cat <<PS_SNIPPET >"$ps_file"
# Auto-generated by scripts/add-cross-shell-tool.sh
# Adds $tool_name to PATH when available.

\$toolDir = Get-UserProfilePath -Segments $ps_segment_array
if (Test-Path -LiteralPath \$toolDir) {
    Add-PathIfMissing -Path \$toolDir
}
PS_SNIPPET

echo "âœ… Created cross-shell definitions for '$tool_name'"
echo "  POSIX: $posix_file"
echo "  PowerShell: $ps_file"
echo "Run 'just lint' to include the new files in shellcheck and formatting checks."
