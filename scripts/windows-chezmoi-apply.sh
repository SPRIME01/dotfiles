#!/usr/bin/env bash
# scripts/windows-chezmoi-apply.sh â€” Run chezmoi apply on Windows from WSL using this repo as source
# Usage: windows-chezmoi-apply.sh [SOURCE_DIR]
# Default SOURCE_DIR: $HOME/dotfiles

set -euo pipefail

SRC_DIR="${1:-$HOME/dotfiles}"

echo "ðŸªŸ Chezmoi apply (Windows) from WSL"

if [[ -z "${WSL_DISTRO_NAME:-}" ]]; then
  echo "âŒ This helper is intended to run inside WSL." >&2
  exit 2
fi

if [[ ! -d "$SRC_DIR" ]]; then
  echo "âŒ Source directory not found: $SRC_DIR" >&2
  exit 2
fi

# Validate and remediate .chezmoiignore in source (destination-based patterns)
SRC_IGNORE="$SRC_DIR/.chezmoiignore"
if [[ -f "$SRC_IGNORE" ]]; then
  if grep -qE '^!dot_\*' "$SRC_IGNORE" 2>/dev/null; then
    echo "âš ï¸  Invalid pattern in $SRC_IGNORE: !dot_* (patterns match destination paths). Updating whitelist."
    cp "$SRC_IGNORE" "$SRC_IGNORE.bak.$(date +%s)" 2>/dev/null || true
    cat >"$SRC_IGNORE" <<'EOF'
# Autogenerated minimal whitelist for destination paths
*
!.chezmoiignore
!.*
!.*/**
EOF
  fi
fi

if ! command -v powershell.exe >/dev/null 2>&1 && ! command -v pwsh.exe >/dev/null 2>&1; then
  echo "âŒ powershell.exe / pwsh.exe not found from WSL." >&2
  exit 3
fi

# Build a UNC path to the WSL source directory for Windows to read templates directly
UNC="\\\\wsl.localhost\\${WSL_DISTRO_NAME}$(printf '%s' "$SRC_DIR" | sed 's#^/#\\#; s#/#\\#g')"

# Prefer pwsh.exe if present for better unicode handling
PSBIN="pwsh.exe"; command -v pwsh.exe >/dev/null 2>&1 || PSBIN="powershell.exe"

# Write a temporary PowerShell script in WSL and pass its Windows path to -File
PS_TMP="$(mktemp --suffix=.ps1)"
cat >"$PS_TMP" <<'EOF'
param(
  [Parameter(Mandatory=$true)][string]$Src
)
Write-Host "ðŸ”§ Applying Chezmoi from source: $Src" -ForegroundColor Cyan
if (-not (Get-Command chezmoi.exe -ErrorAction SilentlyContinue)) {
  Write-Warning "chezmoi.exe not found on Windows PATH. Install with: choco install chezmoi or winget install chezmoi"
  exit 4
}
try {
  chezmoi.exe apply --source $Src -v
  $code = $LASTEXITCODE
  if ($code -eq 0) { Write-Host "âœ… Windows apply complete" -ForegroundColor Green }
  exit $code
} catch {
  Write-Error $_.Exception.Message
  exit 5
}
EOF
PS_TMP_WIN="$(wslpath -w "$PS_TMP")"
"$PSBIN" -NoProfile -ExecutionPolicy Bypass -File "$PS_TMP_WIN" -Src "$UNC"
rc=$?
rm -f -- "$PS_TMP" || true
exit $rc
#!/usr/bin/env bash
set -euo pipefail

SRC="${SRC:-$HOME/dotfiles}"
DEST="${DEST:-}"

# If DEST not set, try to discover Windows UserProfile via powershell.exe or cmd.exe (WSL interop)
winpath=""
if [[ -z "$DEST" ]]; then
    if command -v powershell.exe >/dev/null 2>&1; then
        winpath=$(powershell.exe -NoProfile -Command '$env:USERPROFILE' 2>/dev/null | tr -d '\r' || true)
    elif command -v cmd.exe >/dev/null 2>&1; then
        winpath=$(cmd.exe /c "echo %USERPROFILE%" 2>/dev/null | tr -d '\r' || true)
    fi

    if [[ -n "$winpath" ]]; then
        if command -v wslpath >/dev/null 2>&1; then
            DEST="$(wslpath -a "$winpath")"
        else
            DEST="$winpath"
        fi
    fi
fi

if [[ -z "$DEST" ]]; then
    echo "ERROR: Destination not set. Provide DEST=/mnt/c/Users/You or run from WSL with powershell.exe/cmd.exe available." >&2
    exit 2
fi

if ! command -v chezmoi >/dev/null 2>&1; then
    echo "ERROR: 'chezmoi' not found on PATH." >&2
    exit 127
fi

# Pre-flight: fix Windows PowerShell 7 profile if it's a broken symlink from WSL's perspective
sanitize_pwsh7_profile() {
  local dest_root="$1"
  local psfile="$dest_root/Documents/PowerShell/Microsoft.PowerShell_profile.ps1"
  if [[ -L "$psfile" ]]; then
    if ! readlink "$psfile" >/dev/null 2>&1; then
      local have_pwsh=0; command -v pwsh.exe >/dev/null 2>&1 && have_pwsh=1
      local psbin="powershell.exe"; [[ $have_pwsh -eq 1 ]] && psbin="pwsh.exe"
      local dotfiles_unc="\\\\wsl.localhost\\${WSL_DISTRO_NAME}\\home\\${USER}\\dotfiles"
      local win_user
      win_user=$(cmd.exe /c "echo %USERNAME%" 2>/dev/null | tr -d '\r' || true)
      local projects_win="C:\\Users\\${win_user}\\projects"
      # Build loader content
      local content
      content=$(cat <<'EOF'
# Windows PowerShell 7 Profile - Generated by windows-chezmoi-apply.sh
# Loads main profile from WSL dotfiles
$env:DOTFILES_ROOT = "__DOTFILES_UNC__"
if (-not $env:PROJECTS_ROOT) { $env:PROJECTS_ROOT = "__PROJECTS_WIN__" }
$main = Join-Path $env:DOTFILES_ROOT 'PowerShell\Microsoft.PowerShell_profile.ps1'
try { . $main } catch { Write-Warning $_.Exception.Message }
EOF
)
      content=${content/__DOTFILES_UNC__/$dotfiles_unc}
      content=${content/__PROJECTS_WIN__/$projects_win}
      local b64; b64=$(printf '%s' "$content" | base64 | tr -d '\n')
      local psfile_win
      psfile_win=$(printf '%s' "$psfile" | sed -E 's|^/mnt/([a-zA-Z])/|\U\1:\\|; s|/|\\\\|g')
      "$psbin" -NoProfile -NonInteractive -Command "try { \$p='${psfile_win}'; \$d=Split-Path -Parent \$p; if (-not (Test-Path \$d)) { New-Item -ItemType Directory -Path \$d -Force | Out-Null }; if (Test-Path \$p) { Remove-Item -Path \$p -Force -ErrorAction SilentlyContinue }; \$bytes=[Convert]::FromBase64String('${b64}'); \$text=[Text.Encoding]::UTF8.GetString(\$bytes); [IO.File]::WriteAllText(\$p, \$text, [Text.Encoding]::UTF8); exit 0 } catch { exit 1 }" >/dev/null 2>&1 || true
    fi
  fi
}

sanitize_pwsh7_profile "$DEST"

# Avoid interactive pager prompts from chezmoi
export CHEZMOI_NO_PAGER=1
export PAGER="${PAGER:-cat}"
export GIT_PAGER=cat
export LESS=FRX

has_broken_pwsh_symlink() {
  local psfile="$DEST/Documents/PowerShell/Microsoft.PowerShell_profile.ps1"
  [[ -L "$psfile" ]] && ! readlink "$psfile" >/dev/null 2>&1
}

set +e
chezmoi apply --no-pager --no-tty --force --keep-going --source "$SRC" --destination "$DEST" --verbose
rc=$?
set -e
if [[ $rc -ne 0 ]] && has_broken_pwsh_symlink; then
  echo "â„¹ï¸  Ignoring known Windows symlink readlink error for Microsoft.PowerShell_profile.ps1" >&2
  exit 0
fi
exit $rc
