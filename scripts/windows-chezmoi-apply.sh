#!/usr/bin/env bash
set -euo pipefail

SRC="${SRC:-$HOME/dotfiles}"
DEST="${DEST:-}"

# If DEST not set, try to discover Windows UserProfile via powershell.exe or cmd.exe (WSL interop)
winpath=""
if [[ -z "$DEST" ]]; then
    if command -v powershell.exe >/dev/null 2>&1; then
        winpath=$(powershell.exe -NoProfile -Command '$env:USERPROFILE' 2>/dev/null | tr -d '\r' || true)
    elif command -v cmd.exe >/dev/null 2>&1; then
        winpath=$(cmd.exe /c "echo %USERPROFILE%" 2>/dev/null | tr -d '\r' || true)
    fi

    if [[ -n "$winpath" ]]; then
        if command -v wslpath >/dev/null 2>&1; then
            DEST="$(wslpath -a "$winpath")"
        else
            DEST="$winpath"
        fi
    fi
fi

if [[ -z "$DEST" ]]; then
    echo "ERROR: Destination not set. Provide DEST=/mnt/c/Users/You or run from WSL with powershell.exe/cmd.exe available." >&2
    exit 2
fi

if ! command -v chezmoi >/dev/null 2>&1; then
    echo "ERROR: 'chezmoi' not found on PATH." >&2
    exit 127
fi

# Pre-flight: fix Windows PowerShell 7 profile if it's a broken symlink from WSL's perspective
sanitize_pwsh7_profile() {
  local dest_root="$1"
  local psfile="$dest_root/Documents/PowerShell/Microsoft.PowerShell_profile.ps1"
  if [[ -L "$psfile" ]]; then
    if ! readlink "$psfile" >/dev/null 2>&1; then
      local have_pwsh=0; command -v pwsh.exe >/dev/null 2>&1 && have_pwsh=1
      local psbin="powershell.exe"; [[ $have_pwsh -eq 1 ]] && psbin="pwsh.exe"
      local dotfiles_unc="\\\\wsl.localhost\\${WSL_DISTRO_NAME}\\home\\${USER}\\dotfiles"
      local win_user
      win_user=$(cmd.exe /c "echo %USERNAME%" 2>/dev/null | tr -d '\r' || true)
      local projects_win="C:\\Users\\${win_user}\\projects"
      # Build loader content
      local content
      content=$(cat <<'EOF'
# Windows PowerShell 7 Profile - Generated by windows-chezmoi-apply.sh
# Loads main profile from WSL dotfiles
$env:DOTFILES_ROOT = "__DOTFILES_UNC__"
if (-not $env:PROJECTS_ROOT) { $env:PROJECTS_ROOT = "__PROJECTS_WIN__" }
$main = Join-Path $env:DOTFILES_ROOT 'PowerShell\Microsoft.PowerShell_profile.ps1'
try { . $main } catch { Write-Warning $_.Exception.Message }
EOF
)
      content=${content/__DOTFILES_UNC__/$dotfiles_unc}
      content=${content/__PROJECTS_WIN__/$projects_win}
      local b64; b64=$(printf '%s' "$content" | base64 | tr -d '\n')
      local psfile_win
      psfile_win=$(printf '%s' "$psfile" | sed -E 's|^/mnt/([a-zA-Z])/|\U\1:\\|; s|/|\\\\|g')
      "$psbin" -NoProfile -NonInteractive -Command "try { \$p='${psfile_win}'; \$d=Split-Path -Parent \$p; if (-not (Test-Path \$d)) { New-Item -ItemType Directory -Path \$d -Force | Out-Null }; if (Test-Path \$p) { Remove-Item -Path \$p -Force -ErrorAction SilentlyContinue }; \$bytes=[Convert]::FromBase64String('${b64}'); \$text=[Text.Encoding]::UTF8.GetString(\$bytes); [IO.File]::WriteAllText(\$p, \$text, [Text.Encoding]::UTF8); exit 0 } catch { exit 1 }" >/dev/null 2>&1 || true
    fi
  fi
}

sanitize_pwsh7_profile "$DEST"

# Avoid interactive pager prompts from chezmoi
export CHEZMOI_NO_PAGER=1
export PAGER="${PAGER:-cat}"
export GIT_PAGER=cat
export LESS=FRX

has_broken_pwsh_symlink() {
  local psfile="$DEST/Documents/PowerShell/Microsoft.PowerShell_profile.ps1"
  [[ -L "$psfile" ]] && ! readlink "$psfile" >/dev/null 2>&1
}

set +e
chezmoi apply --no-pager --no-tty --force --keep-going --source "$SRC" --destination "$DEST" --verbose
rc=$?
set -e
if [[ $rc -ne 0 ]] && has_broken_pwsh_symlink; then
  echo "ℹ️  Ignoring known Windows symlink readlink error for Microsoft.PowerShell_profile.ps1" >&2
  exit 0
fi
exit $rc
